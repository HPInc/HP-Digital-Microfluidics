


def: a container is a thing {
  it has an unchangeable capacity;
  it has a volume, initially 0mL;
  it is empty when its volume = 0 mL;
  it may be inherently unusable, by default no;
}

def: a switchable thing {
  it has a binary state;
}

def: a binary state has values on and off;

an xy_position is a thing {
  It has an x (an integer) and a y (an integer).
  // or
  It has an x and a y (integers).
  
  It is in an xy_grid g
    when g's min_x <= its x <= g's max_x
     and g's min_y <= its y <= g's max_y.
}

an xy_grid is a thing {
  It has an unchanging min_x and min_y (integers, by default 0).
  It has an unchanging max_x and max_y (integers).

  It contains an xy_position when the xy_position is in it.
}

the board is a unique thing {
  it has an unchangeable min_row (an integer), max_row (an integer),
                         min_column (an integer), and max_column (an integer);
  its min_col is its min_column;
  its max_col is its max_column;                         
  
  it has a list of wells;

  Its grid is an xy_grid of pads.
  Its min_col (or min_column) is its grid's min_x;
  Its max_col (or max_column) is its grid's max_x;
  Its min_row is its grid's min_y.
  Its max_row is its grid's max_y.
}

// want to concisely say that this preserves over delta and
// addition operations.  Maybe just "An xy_position xy ...".

A literal xy_position xy refers to a pad with xy_position = xy.   

def: a magnet is a switchable thing;


def: a pad is a container and a switchable thing {
  it has an unchangeable row (an integer) and col (an integer);
  its column is its col;
  
  it is on_the_board 
    when 0<=its row<=the board's max_row
     and 0<=its col<=the board's max_col;
  
  
  // or
  It has an unchangeable position (an xy_position in the board's grid).
  Its column (or col) is its position's x.
  Its row is its position's y.
  It is on the board when its position is in the board's grid.
  
  
  // we should be able to infer from "it is empty" that "its volume" is
  // 0ml.
  it may hold a drop;
  when it has a drop,
    its volume is its drop's volume;
  otherwise
    it is empty;
  
  
  // This allows you to say "if p's up_neighbor exists"
  its up_neighbor = it-1 row when that is on_the board;
  its down_neighbor = it+1 row when that is on_the board;
  its left_neighbor = it-1 col when that is on_the board;
  its right_neighbor = it+1 col when that is on_the board;
}

// I probably shouldn't have to say "is a pad"
def: a magnetic pad is a pad {
  // how do I distinguish between things that must be provided to the ctor and those that
  // are created by default?
  it has a magnet;
}

def: a well is a container {
  it has an exit_pad (a pad);
  its remaining_capacity is its capacity - its volume;
  it is full when its remaining_capacity is 0mL;
  
  it can dispense(a volume v = 1 drop) 
  when its volume >= the volume and its exit_pad is empty
  by {
    reserving its exit pad {
      have the board dispense(source_well = it, volume = v);
      create a drop 
        with pad = its exit_pad and volume = v;
      decrease the well's volume by v;
      set its exit_pad's drop to the drop;
    }
  }
  
  it can absorb
  when its remaining_capacity >= its exit_pad's capacity
   and its exit_pad is not empty
  by {
    reserving its exit pad {
      let v be its exit_pad's volume;
      have the board absorb(dest_well = it, volume = v);
      increase its volume by v;

      let d be its exit_pad's drop;
      have its exit_pad lose its drop;
      destroy d;
      
      // or maybe
      Have its exit_pad lose its drop.
      Destroy its exit_pad's former drop.
      // considering using capitals at beginning and periods at end.
     
    }
  }
}

// for a given platform 
def: the board's min_row is 1;
def: the board's min_col is 1;
def: the board's max_row is 13;
def: the board's max_col is 8;

def: a well's capacity is 200uL;

def: a big well is a well {
  its capacity is 2ml;
}

def: a drop is a thing {
  /*
   * Attributes
   */
  it has a pad;
  its position is its pad;
  it has a volume;
  it may have a reagent;
  it has a mix count;  
  it may have beads, initially no;
  
  /* 
   * properties
   */
  // This licenses "a new pad", I think
  it is new when its mix count = 0;
  
  it can split when its volume > 0.5 uL;
   
  
  /*
   * relations
   */
  it can enter a well when its pad==the well's exit_pad;
  it is next_to another drop when its pad is next_to the drop's pad;
  
  // Trying to figure out how to make relations based on attributes
  it is bigger than another drop based on [having] more volume;
  it is bigger than another drop with less volume;   
  it is bigger than another drop that has less volume;   
  it is bigger than another drop when it has more volume;
  it is bigger than a drop d when its volume > d's volume;
  
  it is on a path when some pad in the path's pads = its pad;    
}

// Do we want to be able to specify units that we will use, so that only those can come 
// after numbers and the rest will be syntax errors?  We might be able to get away with 
// a general "name" for units and figure out dimensionality from there.

Allow units: mL, uL.
Allow all volume units.
Allow all SI volume units.

def: distance is a physical dimension.
def: volume is distance^3.
def: SI is a system of units.
def: US is a system of units.
def: SI distance unit meter (or metre, abbreviated m) is the base unit.
def: SI volume unit liter (or litre, abbreviated L or l) is 1 dm^3.
def: US distance unit inch (abbreviated in) is (1/2.54)*meter
